<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Simple Podcast - Collaborative Video Podcasting</title>
        <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }

            body {
                font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
                background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
                min-height: 100vh;
                color: #333;
            }

            .container {
                max-width: 1400px;
                margin: 0 auto;
                padding: 20px;
            }

            /* Header */
            .header {
                text-align: center;
                margin-bottom: 30px;
                padding: 20px;
                background: rgba(255, 255, 255, 0.1);
                backdrop-filter: blur(10px);
                border-radius: 20px;
                border: 1px solid rgba(255, 255, 255, 0.2);
            }

            .header h1 {
                font-size: 3em;
                font-weight: 700;
                background: linear-gradient(45deg, #fff, #f0f0f0);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                margin-bottom: 10px;
            }

            .header p {
                color: rgba(255, 255, 255, 0.9);
                font-size: 1.2em;
                font-weight: 300;
            }

            /* Main Content Sections */
            .section {
                background: rgba(255, 255, 255, 0.95);
                border-radius: 20px;
                padding: 30px;
                margin-bottom: 20px;
                box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
                backdrop-filter: blur(10px);
                border: 1px solid rgba(255, 255, 255, 0.3);
            }

            .section h2 {
                color: #333;
                margin-bottom: 20px;
                font-size: 1.8em;
                font-weight: 600;
            }

            /* Welcome Screen */
            .welcome-screen {
                text-align: center;
            }

            .action-buttons {
                display: flex;
                gap: 20px;
                justify-content: center;
                margin: 30px 0;
                flex-wrap: wrap;
            }

            .btn {
                padding: 15px 30px;
                border: none;
                border-radius: 50px;
                font-size: 16px;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s ease;
                text-decoration: none;
                display: inline-flex;
                align-items: center;
                gap: 10px;
                min-width: 200px;
                justify-content: center;
            }

            .btn-primary {
                background: linear-gradient(45deg, #667eea, #764ba2);
                color: white;
                box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
            }

            .btn-secondary {
                background: linear-gradient(45deg, #f093fb, #f5576c);
                color: white;
                box-shadow: 0 4px 15px rgba(240, 147, 251, 0.4);
            }

            .btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            }

            .btn:disabled {
                opacity: 0.6;
                cursor: not-allowed;
                transform: none;
            }

            /* Session Setup */
            .setup-form {
                max-width: 600px;
                margin: 0 auto;
            }

            .form-group {
                margin-bottom: 20px;
            }

            .form-group label {
                display: block;
                margin-bottom: 8px;
                font-weight: 600;
                color: #555;
            }

            .form-group input,
            .form-group textarea {
                width: 100%;
                padding: 12px 16px;
                border: 2px solid #e1e5e9;
                border-radius: 10px;
                font-size: 16px;
                transition: border-color 0.3s ease;
            }

            .form-group input:focus,
            .form-group textarea:focus {
                outline: none;
                border-color: #667eea;
            }

            /* Device Testing */
            .device-test {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin: 20px 0;
            }

            .preview-box {
                background: #000;
                border-radius: 15px;
                overflow: hidden;
                position: relative;
                aspect-ratio: 16/9;
            }

            .preview-box video {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .preview-label {
                position: absolute;
                top: 15px;
                left: 15px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: 600;
            }

            .audio-levels {
                position: absolute;
                bottom: 15px;
                left: 15px;
                right: 15px;
                height: 6px;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 3px;
                overflow: hidden;
            }

            .audio-level {
                height: 100%;
                background: linear-gradient(90deg, #4CAF50, #FFC107, #FF5722);
                border-radius: 3px;
                transition: width 0.1s ease;
                width: 0%;
            }

            /* Session Interface */
            .session-interface {
                display: none !important;
            }

            .session-interface.active {
                display: block !important;
            }

            .session-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 20px;
                padding: 20px;
                background: #f8f9fa;
                border-radius: 15px;
            }

            .session-info h3 {
                color: #333;
                margin-bottom: 5px;
            }

            .session-status {
                display: flex;
                align-items: center;
                gap: 8px;
                color: #666;
            }

            .status-dot {
                width: 12px;
                height: 12px;
                border-radius: 50%;
                animation: pulse 2s infinite;
            }

            .status-connected {
                background: #4CAF50;
            }

            .status-connecting {
                background: #FF9800;
            }

            .status-disconnected {
                background: #F44336;
            }

            .status-recording {
                background: #E91E63;
            }

            @keyframes pulse {

                0%,
                100% {
                    opacity: 1;
                }

                50% {
                    opacity: 0.5;
                }
            }

            .video-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 20px;
                margin: 20px 0;
            }

            .participant-video {
                background: #000;
                border-radius: 15px;
                overflow: hidden;
                position: relative;
                aspect-ratio: 16/9;
            }

            .participant-video video {
                width: 100%;
                height: 100%;
                object-fit: cover;
            }

            .participant-info {
                position: absolute;
                bottom: 15px;
                left: 15px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 8px 16px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: 600;
            }

            .controls-panel {
                display: flex;
                justify-content: center;
                gap: 15px;
                margin: 20px 0;
                flex-wrap: wrap;
            }

            .control-btn {
                width: 60px;
                height: 60px;
                border: none;
                border-radius: 50%;
                cursor: pointer;
                transition: all 0.3s ease;
                display: flex;
                align-items: center;
                justify-content: center;
                font-size: 24px;
                color: white;
            }

            .control-btn.mute {
                background: #FF5722;
            }

            .control-btn.video {
                background: #2196F3;
            }

            .control-btn.record {
                background: #E91E63;
            }

            .control-btn.end {
                background: #F44336;
            }

            .control-btn:hover {
                transform: scale(1.1);
            }

            .control-btn.active {
                box-shadow: 0 0 0 4px rgba(255, 255, 255, 0.3);
            }

            .recording-timer {
                text-align: center;
                font-size: 2em;
                font-weight: bold;
                color: #E91E63;
                font-family: 'Courier New', monospace;
                margin: 20px 0;
            }

            /* Connection Status */
            .connection-quality {
                display: flex;
                align-items: center;
                gap: 10px;
                font-size: 14px;
                color: #666;
            }

            .quality-bars {
                display: flex;
                gap: 2px;
            }

            .quality-bar {
                width: 4px;
                height: 12px;
                background: #ddd;
                border-radius: 2px;
            }

            .quality-bar.active {
                background: #4CAF50;
            }

            .quality-bar.medium {
                background: #FF9800;
            }

            .quality-bar.poor {
                background: #F44336;
            }

            /* Share Link */
            .share-section {
                background: #e8f4fd;
                border-radius: 10px;
                padding: 20px;
                margin: 20px 0;
                border-left: 4px solid #2196F3;
            }

            .share-link {
                display: flex;
                gap: 10px;
                align-items: center;
                margin-top: 10px;
            }

            .share-link input {
                flex: 1;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 5px;
                font-family: monospace;
                background: white;
            }

            .copy-btn {
                padding: 10px 20px;
                background: #2196F3;
                color: white;
                border: none;
                border-radius: 5px;
                cursor: pointer;
                font-weight: 600;
            }

            /* Responsive Design */
            @media (max-width: 768px) {

                .device-test,
                .video-grid {
                    grid-template-columns: 1fr;
                }

                .action-buttons {
                    flex-direction: column;
                    align-items: center;
                }

                .controls-panel {
                    justify-content: space-around;
                }

                .session-header {
                    flex-direction: column;
                    gap: 15px;
                    text-align: center;
                }
            }

            /* Utility Classes */
            .hidden {
                display: none !important;
            }

            .text-center {
                text-align: center;
            }

            .mb-20 {
                margin-bottom: 20px;
            }

            .mt-20 {
                margin-top: 20px;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <!-- Header -->
            <div class="header">
                <h1>üéôÔ∏è Simple Podcast</h1>
                <p>Create collaborative video podcasts with friends in real-time</p>
            </div>

            <!-- Welcome Screen -->
            <div id="welcomeScreen" class="section welcome-screen">
                <h2>Welcome to Simple Podcast</h2>
                <p>Start a podcast session and invite a friend to create amazing content together!</p>

                <div class="action-buttons">
                    <button id="createSessionBtn" class="btn btn-primary">
                        üé¨ Create New Podcast
                    </button>
                    <button id="joinSessionBtn" class="btn btn-secondary">
                        üéØ Join Existing Podcast
                    </button>
                </div>

                <div id="joinForm" class="setup-form hidden">
                    <div class="form-group">
                        <label for="sessionIdInput">Session ID or Link:</label>
                        <input type="text" id="sessionIdInput" placeholder="Enter session ID or paste invite link">
                    </div>
                    <div class="form-group">
                        <label for="guestNameInput">Your Name:</label>
                        <input type="text" id="guestNameInput" placeholder="Enter your name">
                    </div>
                    <button id="joinSessionConfirm" class="btn btn-primary">Join Session</button>
                    <button id="cancelJoin" class="btn btn-secondary">Cancel</button>
                </div>
            </div>

            <!-- Session Setup -->
            <div id="sessionSetup" class="section hidden">
                <h2>Setup Your Podcast</h2>
                <div class="setup-form">
                    <div class="form-group">
                        <label for="podcastTitle">Podcast Title:</label>
                        <input type="text" id="podcastTitle" placeholder="Enter your podcast title" value="My Awesome Podcast">
                    </div>
                    <div class="form-group">
                        <label for="hostName">Your Name:</label>
                        <input type="text" id="hostName" placeholder="Enter your name" value="Host">
                    </div>
                    <div class="form-group">
                        <label for="podcastDescription">Description (Optional):</label>
                        <textarea id="podcastDescription" rows="3" placeholder="Brief description of your podcast episode"></textarea>
                    </div>
                    <button id="setupDevicesBtn" class="btn btn-primary">Test Devices & Continue</button>
                </div>
            </div>

            <!-- Device Testing -->
            <div id="deviceTesting" class="section hidden">
                <h2>Test Your Camera & Microphone</h2>
                <p class="text-center mb-20">Make sure your devices are working properly before starting the session.</p>

                <div class="device-test">
                    <div class="preview-box">
                        <div class="preview-label">Your Camera</div>
                        <video id="localVideo" autoplay muted></video>
                        <div class="audio-levels">
                            <div id="localAudioLevel" class="audio-level"></div>
                        </div>
                    </div>
                    <div class="preview-box" style="background: linear-gradient(45deg, #333, #555); display: flex; align-items: center; justify-content: center; color: white;">
                        <div style="text-align: center;">
                            <div style="font-size: 3em; margin-bottom: 10px;">üë•</div>
                            <div>Waiting for guest to join...</div>
                        </div>
                    </div>
                </div>

                <div class="share-section">
                    <h4>Share this link with your podcast guest:</h4>
                    <div class="share-link">
                        <input type="text" id="shareLink" readonly>
                        <button id="copyLinkBtn" class="copy-btn">Copy Link</button>
                    </div>
                </div>

                <div class="action-buttons">
                    <button id="startWaitingBtn" class="btn btn-primary">Ready - Wait for Guest</button>
                    <button id="backToSetupBtn" class="btn btn-secondary">Back to Setup</button>
                </div>
            </div>

            <!-- Session Interface -->
            <div id="sessionInterface" class="section session-interface">
                <div class="session-header">
                    <div class="session-info">
                        <h3 id="sessionTitle">My Awesome Podcast</h3>
                        <div class="session-status">
                            <div id="connectionStatus" class="status-dot status-connecting"></div>
                            <span id="connectionText">Connecting...</span>
                            <div class="connection-quality">
                                <span>Quality:</span>
                                <div class="quality-bars">
                                    <div class="quality-bar active"></div>
                                    <div class="quality-bar active"></div>
                                    <div class="quality-bar active"></div>
                                    <div class="quality-bar"></div>
                                    <div class="quality-bar"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="recordingTimer" class="recording-timer hidden">00:00:00</div>
                </div>

                <div class="video-grid">
                    <div class="participant-video">
                        <video id="hostVideo" autoplay muted></video>
                        <div class="participant-info">
                            <span id="hostLabel">You (Host)</span>
                        </div>
                        <div class="audio-levels">
                            <div id="hostAudioLevel" class="audio-level"></div>
                        </div>
                    </div>
                    <div class="participant-video">
                        <video id="guestVideo" autoplay></video>
                        <div class="participant-info">
                            <span id="guestLabel">Guest</span>
                        </div>
                        <div class="audio-levels">
                            <div id="guestAudioLevel" class="audio-level"></div>
                        </div>
                    </div>
                </div>

                <div class="controls-panel">
                    <button id="muteBtn" class="control-btn mute" title="Mute/Unmute Microphone">
                        üé§
                    </button>
                    <button id="videoBtn" class="control-btn video" title="Turn Camera On/Off">
                        üìπ
                    </button>
                    <button id="recordBtn" class="control-btn record" title="Start/Stop Recording">
                        ‚è∫Ô∏è
                    </button>
                    <button id="endBtn" class="control-btn end" title="End Session">
                        üìû
                    </button>
                </div>

                <div id="recordingStatus" class="text-center hidden">
                    <p style="color: #E91E63; font-weight: 600; font-size: 18px;">üî¥ Recording in progress...</p>
                </div>
            </div>
        </div>

        <script>
            class SimplePodcast {
                constructor() {
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.mediaRecorder = null;
                    this.recordedChunks = [];
                    this.isHost = false;
                    this.isRecording = false;
                    this.sessionId = null;
                    this.participantName = '';
                    this.recordingStartTime = null;
                    this.guestName = '';
                    this.isConnected = false;

                    // Session storage for peer-to-peer signaling
                    this.sessionData = null;
                    this.signalingInterval = null;

                    // WebRTC Configuration
                    this.rtcConfig = {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    };

                    this.initializeApp();
                }

                initializeApp() {
                    this.bindEvents();
                    this.checkUrlParams();
                }

                bindEvents() {
                    // Welcome screen events
                    document.getElementById('createSessionBtn').addEventListener('click', () => this.showSessionSetup());
                    document.getElementById('joinSessionBtn').addEventListener('click', () => this.showJoinForm());
                    document.getElementById('cancelJoin').addEventListener('click', () => this.hideJoinForm());
                    document.getElementById('joinSessionConfirm').addEventListener('click', () => this.joinSession());

                    // Setup events
                    document.getElementById('setupDevicesBtn').addEventListener('click', () => this.setupDevices());
                    document.getElementById('backToSetupBtn').addEventListener('click', () => this.showSessionSetup());
                    document.getElementById('startWaitingBtn').addEventListener('click', () => this.startWaitingForGuest());

                    // Device testing events
                    document.getElementById('copyLinkBtn').addEventListener('click', () => this.copyShareLink());

                    // Session control events
                    document.getElementById('muteBtn').addEventListener('click', () => this.toggleMute());
                    document.getElementById('videoBtn').addEventListener('click', () => this.toggleVideo());
                    document.getElementById('recordBtn').addEventListener('click', () => this.toggleRecording());
                    document.getElementById('endBtn').addEventListener('click', () => this.endSession());
                }

                checkUrlParams() {
                    const urlParams = new URLSearchParams(window.location.search);
                    const sessionId = urlParams.get('session');
                    if (sessionId) {
                        this.sessionId = sessionId;
                        this.showJoinForm();
                        document.getElementById('sessionIdInput').value = sessionId;
                    }
                }

                generateSessionId() {
                    return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
                }

                showSessionSetup() {
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('sessionSetup').classList.remove('hidden');
                    this.isHost = true;
                }

                showJoinForm() {
                    document.getElementById('joinForm').classList.remove('hidden');
                    document.querySelector('.action-buttons').classList.add('hidden');
                }

                hideJoinForm() {
                    document.getElementById('joinForm').classList.add('hidden');
                    document.querySelector('.action-buttons').classList.remove('hidden');
                }

                async setupDevices() {
                    const title = document.getElementById('podcastTitle').value || 'My Awesome Podcast';
                    const hostName = document.getElementById('hostName').value || 'Host';

                    if (!title.trim() || !hostName.trim()) {
                        alert('Please fill in the required fields.');
                        return;
                    }

                    this.participantName = hostName;
                    this.sessionId = this.generateSessionId();

                    try {
                        await this.initializeLocalMedia();
                        this.showDeviceTesting();
                        this.generateShareLink();
                    } catch (error) {
                        console.error('Error setting up devices:', error);
                        alert('Could not access camera/microphone. Please check permissions.');
                    }
                }

                async initializeLocalMedia() {
                    try {
                        this.localStream = await navigator.mediaDevices.getUserMedia({
                            video: { width: 1280, height: 720 },
                            audio: { echoCancellation: true, noiseSuppression: true }
                        });

                        const localVideo = document.getElementById('localVideo');
                        localVideo.srcObject = this.localStream;

                        this.setupAudioLevelMonitoring();
                    } catch (error) {
                        throw new Error('Failed to access media devices: ' + error.message);
                    }
                }

                setupAudioLevelMonitoring() {
                    const audioContext = new AudioContext();
                    const analyser = audioContext.createAnalyser();
                    const microphone = audioContext.createMediaStreamSource(this.localStream);

                    analyser.fftSize = 256;
                    microphone.connect(analyser);

                    const dataArray = new Uint8Array(analyser.frequencyBinCount);

                    const updateAudioLevel = () => {
                        analyser.getByteFrequencyData(dataArray);
                        const average = dataArray.reduce((sum, value) => sum + value, 0) / dataArray.length;
                        const percentage = (average / 255) * 100;

                        const audioLevel = document.getElementById('localAudioLevel');
                        if (audioLevel) {
                            audioLevel.style.width = `${percentage}%`;
                        }

                        requestAnimationFrame(updateAudioLevel);
                    };

                    updateAudioLevel();
                }

                showDeviceTesting() {
                    document.getElementById('sessionSetup').classList.add('hidden');
                    document.getElementById('deviceTesting').classList.remove('hidden');
                }

                generateShareLink() {
                    const baseUrl = window.location.origin + window.location.pathname;
                    const shareUrl = `${baseUrl}?session=${this.sessionId}`;
                    document.getElementById('shareLink').value = shareUrl;
                }

                copyShareLink() {
                    const shareLink = document.getElementById('shareLink');
                    shareLink.select();
                    shareLink.setSelectionRange(0, 99999);
                    navigator.clipboard.writeText(shareLink.value).then(() => {
                        const btn = document.getElementById('copyLinkBtn');
                        const originalText = btn.textContent;
                        btn.textContent = 'Copied!';
                        btn.style.background = '#4CAF50';
                        setTimeout(() => {
                            btn.textContent = originalText;
                            btn.style.background = '#2196F3';
                        }, 2000);
                    });
                }

                async startWaitingForGuest() {
                    this.showSessionInterface();
                    this.updateConnectionStatus('connecting', 'Waiting for guest...');

                    // Set up session data in localStorage
                    const sessionData = {
                        sessionId: this.sessionId,
                        hostName: this.participantName,
                        podcastTitle: document.getElementById('podcastTitle').value,
                        created: Date.now(),
                        status: 'waiting'
                    };

                    localStorage.setItem(`session_${this.sessionId}`, JSON.stringify(sessionData));

                    // Also store in global signaling for cross-tab access
                    this.sendBroadcastMessage('session-created', {
                        sessionId: this.sessionId,
                        hostName: this.participantName,
                        podcastTitle: document.getElementById('podcastTitle').value
                    });

                    // Set up WebRTC connection
                    this.setupPeerConnection();

                    // Start listening for signaling messages
                    this.startSignaling();

                    // Show helpful message
                    console.log('Host waiting for guest to join session:', this.sessionId);
                }

                setupPeerConnection() {
                    console.log('Setting up peer connection, isHost:', this.isHost);
                    this.peerConnection = new RTCPeerConnection(this.rtcConfig);

                    // Add local stream tracks first
                    if (this.localStream) {
                        console.log('Adding local stream tracks to peer connection');
                        this.localStream.getTracks().forEach((track, index) => {
                            console.log(`Adding track ${index}:`, track.kind, track.enabled);
                            this.peerConnection.addTrack(track, this.localStream);
                        });
                    } else {
                        console.error('No local stream available when setting up peer connection');
                    }

                    // Handle remote stream
                    this.peerConnection.ontrack = (event) => {
                        console.log('üé• Received remote track:', event.track.kind);
                        console.log('Remote streams count:', event.streams.length);

                        if (event.streams && event.streams[0]) {
                            this.remoteStream = event.streams[0];
                            console.log('Remote stream tracks:', this.remoteStream.getTracks().length);

                            // Determine which video element to use
                            const remoteVideo = this.isHost ?
                                document.getElementById('guestVideo') :
                                document.getElementById('hostVideo');

                            console.log('Setting remote stream to:', this.isHost ? 'guestVideo' : 'hostVideo');

                            // Clear any placeholder content
                            remoteVideo.style.background = 'none';
                            remoteVideo.innerHTML = '';

                            // Set the remote stream
                            remoteVideo.srcObject = this.remoteStream;

                            // Force video to play
                            remoteVideo.play().catch(e => {
                                console.log('Auto-play prevented, user interaction required');
                            });

                            if (!this.isConnected) {
                                this.isConnected = true;
                                this.updateConnectionStatus('connected', 'Connected - Video Active');
                                console.log('‚úÖ Connection established successfully with video');
                            }
                        }
                    };

                    // Handle ICE candidates with better error handling
                    this.peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log('üì° Sending ICE candidate:', event.candidate.type);
                            this.sendSignalingMessage('ice-candidate', {
                                candidate: event.candidate.candidate,
                                sdpMLineIndex: event.candidate.sdpMLineIndex,
                                sdpMid: event.candidate.sdpMid
                            });
                        } else {
                            console.log('All ICE candidates have been sent');
                        }
                    };

                    // Enhanced connection state monitoring
                    this.peerConnection.onconnectionstatechange = () => {
                        const state = this.peerConnection.connectionState;
                        console.log('üîó Connection state changed to:', state);

                        switch (state) {
                            case 'connected':
                                this.updateConnectionStatus('connected', 'Connected');
                                break;
                            case 'disconnected':
                                this.updateConnectionStatus('disconnected', 'Connection lost');
                                break;
                            case 'failed':
                                this.updateConnectionStatus('disconnected', 'Connection failed');
                                console.error('WebRTC connection failed');
                                break;
                            case 'connecting':
                                this.updateConnectionStatus('connecting', 'Connecting...');
                                break;
                        }
                    };

                    // ICE connection state monitoring
                    this.peerConnection.oniceconnectionstatechange = () => {
                        const iceState = this.peerConnection.iceConnectionState;
                        console.log('üßä ICE connection state:', iceState);

                        if (iceState === 'failed') {
                            console.error('ICE connection failed, attempting restart...');
                            this.peerConnection.restartIce();
                        }
                    };

                    // Data channel state monitoring
                    this.peerConnection.ondatachannel = (event) => {
                        console.log('Data channel received:', event.channel.label);
                    };

                    console.log('Peer connection setup complete');
                }

                async createOffer() {
                    try {
                        console.log('Host creating WebRTC offer...');

                        // Ensure we have local stream before creating offer
                        if (!this.localStream) {
                            console.error('No local stream available for offer');
                            return;
                        }

                        const offer = await this.peerConnection.createOffer({
                            offerToReceiveAudio: true,
                            offerToReceiveVideo: true
                        });

                        await this.peerConnection.setLocalDescription(offer);
                        console.log('Host offer created and set as local description');

                        this.sendSignalingMessage('offer', {
                            type: offer.type,
                            sdp: offer.sdp
                        });
                        console.log('Host offer sent to guest');
                    } catch (error) {
                        console.error('Error creating offer:', error);
                    }
                }

                async handleOffer(offerData) {
                    try {
                        console.log('Guest handling offer from host...');

                        const offer = new RTCSessionDescription({
                            type: offerData.type,
                            sdp: offerData.sdp
                        });

                        await this.peerConnection.setRemoteDescription(offer);
                        console.log('Guest set remote description from host offer');

                        const answer = await this.peerConnection.createAnswer({
                            offerToReceiveAudio: true,
                            offerToReceiveVideo: true
                        });

                        await this.peerConnection.setLocalDescription(answer);
                        console.log('Guest created and set local description (answer)');

                        this.sendSignalingMessage('answer', {
                            type: answer.type,
                            sdp: answer.sdp
                        });
                        console.log('Guest answer sent to host');
                    } catch (error) {
                        console.error('Error handling offer:', error);
                    }
                }

                async handleAnswer(answerData) {
                    try {
                        console.log('Host handling answer from guest...');

                        const answer = new RTCSessionDescription({
                            type: answerData.type,
                            sdp: answerData.sdp
                        });

                        await this.peerConnection.setRemoteDescription(answer);
                        console.log('Host set remote description from guest answer');
                        console.log('WebRTC handshake complete');
                    } catch (error) {
                        console.error('Error handling answer:', error);
                    }
                }

                async handleIceCandidate(candidateData) {
                    try {
                        if (candidateData && candidateData.candidate) {
                            const candidate = new RTCIceCandidate({
                                candidate: candidateData.candidate,
                                sdpMLineIndex: candidateData.sdpMLineIndex,
                                sdpMid: candidateData.sdpMid
                            });

                            await this.peerConnection.addIceCandidate(candidate);
                            console.log('ICE candidate added successfully');
                        }
                    } catch (error) {
                        console.error('Error adding ICE candidate:', error);
                    }
                }

                onGuestJoined() {
                    console.log('Guest joined:', this.guestName);
                    this.updateConnectionStatus('connecting', `${this.guestName} is connecting...`);
                    document.getElementById('guestLabel').textContent = this.guestName;

                    // Clear the placeholder content
                    const guestVideo = document.getElementById('guestVideo');
                    guestVideo.style.background = '#000';
                    guestVideo.innerHTML = '';
                }

                onGuestDisconnected() {
                    console.log('Guest disconnected');
                    this.updateConnectionStatus('disconnected', 'Guest disconnected');
                    const guestVideo = document.getElementById('guestVideo');
                    guestVideo.srcObject = null;
                    guestVideo.style.background = 'linear-gradient(45deg, #333, #555)';
                    guestVideo.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 1.5em;">Guest Disconnected</div>';
                }

                async joinSession() {
                    const sessionId = document.getElementById('sessionIdInput').value.trim();
                    const guestName = document.getElementById('guestNameInput').value.trim();

                    if (!sessionId || !guestName) {
                        alert('Please enter both session ID and your name.');
                        return;
                    }

                    // Extract session ID from URL if a full URL was pasted
                    const sessionMatch = sessionId.match(/session=([^&]+)/);
                    this.sessionId = sessionMatch ? sessionMatch[1] : sessionId;
                    this.participantName = guestName;
                    this.isHost = false;

                    console.log('üéØ Guest attempting to join session:', this.sessionId);

                    try {
                        // Initialize media first - this is crucial
                        console.log('üé• Guest initializing media...');
                        await this.initializeLocalMedia();
                        console.log('‚úÖ Guest media initialized successfully');

                        // Show session interface immediately
                        this.showSessionInterface();
                        this.updateConnectionStatus('connecting', 'Looking for host...');

                        // Set up videos for guest view
                        const hostVideo = document.getElementById('hostVideo');
                        const guestVideo = document.getElementById('guestVideo');

                        // Guest's own video
                        guestVideo.srcObject = this.localStream;
                        guestVideo.muted = true;

                        // Placeholder for host video
                        hostVideo.style.background = 'linear-gradient(45deg, #667eea, #764ba2)';
                        hostVideo.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 1.5em;">üîç Looking for host...</div>';

                        // Update labels
                        document.getElementById('guestLabel').textContent = `You (${guestName})`;
                        document.getElementById('hostLabel').textContent = 'Host';

                        // Set up WebRTC connection BEFORE signaling
                        console.log('üîó Guest setting up peer connection...');
                        this.setupPeerConnection();

                        // Start signaling and look for host
                        console.log('üì° Guest starting signaling...');
                        this.startSignaling();

                        // Look for existing host session data
                        this.lookForHostSession();

                        // Announce guest presence immediately and repeatedly
                        const announceGuest = () => {
                            console.log('üì¢ Guest announcing presence...');
                            this.sendSignalingMessage('guest-joined', {
                                guestName: guestName,
                                timestamp: Date.now()
                            });

                            this.sendSignalingMessage('guest-looking', {
                                guestName: guestName,
                                sessionId: this.sessionId,
                                timestamp: Date.now()
                            });
                        };

                        // Announce immediately and then every 2 seconds
                        announceGuest();
                        this.guestAnnouncementInterval = setInterval(announceGuest, 2000);

                        // Update status
                        this.updateConnectionStatus('connecting', 'Announcing presence to host...');

                    } catch (error) {
                        console.error('‚ùå Error joining session:', error);
                        alert('Could not access camera/microphone. Please check permissions and try again.');
                    }
                }

                lookForHostSession() {
                    // Check multiple possible locations for host session
                    const possibleKeys = [
                        `session_${this.sessionId}`,
                        `host_session_${this.sessionId}`
                    ];

                    for (const key of possibleKeys) {
                        const sessionData = localStorage.getItem(key);
                        if (sessionData) {
                            try {
                                const session = JSON.parse(sessionData);
                                console.log('üéØ Found host session data:', session);
                                document.getElementById('sessionTitle').textContent = session.podcastTitle;
                                document.getElementById('hostLabel').textContent = session.hostName;
                                this.updateConnectionStatus('connecting', `Found ${session.hostName}, connecting...`);
                                return true;
                            } catch (error) {
                                console.error('Error parsing session data:', error);
                            }
                        }
                    }
                    return false;
                }

                showSessionInterface() {
                    console.log('Showing session interface, isHost:', this.isHost);

                    // Hide all other sections
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    document.getElementById('sessionSetup').classList.add('hidden');
                    document.getElementById('deviceTesting').classList.add('hidden');

                    // Show session interface with stronger CSS override
                    const sessionInterface = document.getElementById('sessionInterface');
                    sessionInterface.classList.remove('hidden');
                    sessionInterface.classList.add('active');
                    sessionInterface.style.display = 'block';
                    sessionInterface.style.visibility = 'visible';

                    // Set session title
                    const title = document.getElementById('podcastTitle')?.value || 'Simple Podcast Session';
                    document.getElementById('sessionTitle').textContent = title;

                    // Setup host video if host
                    if (this.isHost && this.localStream) {
                        const hostVideo = document.getElementById('hostVideo');
                        hostVideo.srcObject = this.localStream;
                        hostVideo.muted = true;
                        document.getElementById('hostLabel').textContent = `You (${this.participantName})`;
                        document.getElementById('guestLabel').textContent = 'Waiting for Guest...';

                        // Set placeholder for guest video
                        const guestVideo = document.getElementById('guestVideo');
                        guestVideo.style.background = 'linear-gradient(45deg, #333, #555)';
                        guestVideo.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 1.5em;">üë• Waiting for guest...</div>';
                    }

                    console.log('Session interface should now be visible');
                }

                updateConnectionStatus(status, text) {
                    const statusDot = document.getElementById('connectionStatus');
                    const statusText = document.getElementById('connectionText');

                    statusDot.className = `status-dot status-${status}`;
                    statusText.textContent = text;
                }

                toggleMute() {
                    const audioTrack = this.localStream.getAudioTracks()[0];
                    if (audioTrack) {
                        audioTrack.enabled = !audioTrack.enabled;
                        const muteBtn = document.getElementById('muteBtn');
                        muteBtn.innerHTML = audioTrack.enabled ? 'üé§' : 'üîá';
                        muteBtn.classList.toggle('active', !audioTrack.enabled);
                    }
                }

                toggleVideo() {
                    const videoTrack = this.localStream.getVideoTracks()[0];
                    if (videoTrack) {
                        videoTrack.enabled = !videoTrack.enabled;
                        const videoBtn = document.getElementById('videoBtn');
                        videoBtn.innerHTML = videoTrack.enabled ? 'üìπ' : 'üì∑';
                        videoBtn.classList.toggle('active', !videoTrack.enabled);
                    }
                }

                async toggleRecording() {
                    if (!this.isHost) {
                        alert('Only the host can control recording.');
                        return;
                    }

                    if (this.isRecording) {
                        this.stopRecording();
                    } else {
                        this.startRecording();
                    }
                }

                async startRecording() {
                    try {
                        // Create a canvas to composite both video streams
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 1920;
                        canvas.height = 1080;

                        const hostVideo = document.getElementById('hostVideo');
                        const guestVideo = document.getElementById('guestVideo');

                        // Create a new stream from the canvas
                        const canvasStream = canvas.captureStream(30);

                        // Add audio from local stream
                        const audioTrack = this.localStream.getAudioTracks()[0];
                        if (audioTrack) {
                            canvasStream.addTrack(audioTrack);
                        }

                        // Set up MediaRecorder
                        this.mediaRecorder = new MediaRecorder(canvasStream, {
                            mimeType: 'video/webm;codecs=vp9,opus'
                        });

                        this.recordedChunks = [];
                        this.mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                this.recordedChunks.push(event.data);
                            }
                        };

                        this.mediaRecorder.onstop = () => {
                            this.saveRecording();
                        };

                        // Start compositing video
                        const drawFrame = () => {
                            if (!this.isRecording) return;

                            ctx.fillStyle = '#000';
                            ctx.fillRect(0, 0, canvas.width, canvas.height);

                            // Draw host video (left side)
                            if (hostVideo.videoWidth > 0) {
                                ctx.drawImage(hostVideo, 0, 0, canvas.width / 2, canvas.height);
                            }

                            // Draw guest video (right side)
                            if (guestVideo.videoWidth > 0) {
                                ctx.drawImage(guestVideo, canvas.width / 2, 0, canvas.width / 2, canvas.height);
                            } else {
                                // Placeholder for guest
                                ctx.fillStyle = '#333';
                                ctx.fillRect(canvas.width / 2, 0, canvas.width / 2, canvas.height);
                                ctx.fillStyle = '#fff';
                                ctx.font = '48px Arial';
                                ctx.textAlign = 'center';
                                ctx.fillText('Waiting for Guest', canvas.width * 0.75, canvas.height / 2);
                            }

                            // Add recording timestamp
                            const now = Date.now();
                            const elapsed = Math.floor((now - this.recordingStartTime) / 1000);
                            const timeStr = this.formatTime(elapsed);

                            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                            ctx.fillRect(canvas.width - 200, 20, 180, 60);
                            ctx.fillStyle = '#ff4444';
                            ctx.font = '24px Arial';
                            ctx.textAlign = 'center';
                            ctx.fillText('üî¥ REC', canvas.width - 110, 45);
                            ctx.fillText(timeStr, canvas.width - 110, 70);

                            requestAnimationFrame(drawFrame);
                        };

                        this.mediaRecorder.start();
                        this.isRecording = true;
                        this.recordingStartTime = Date.now();

                        // Update UI
                        const recordBtn = document.getElementById('recordBtn');
                        recordBtn.innerHTML = '‚èπÔ∏è';
                        recordBtn.classList.add('active');

                        document.getElementById('recordingTimer').classList.remove('hidden');
                        document.getElementById('recordingStatus').classList.remove('hidden');

                        this.startRecordingTimer();
                        drawFrame();

                    } catch (error) {
                        console.error('Error starting recording:', error);
                        alert('Could not start recording: ' + error.message);
                    }
                }

                stopRecording() {
                    if (this.mediaRecorder && this.isRecording) {
                        this.mediaRecorder.stop();
                        this.isRecording = false;

                        // Update UI
                        const recordBtn = document.getElementById('recordBtn');
                        recordBtn.innerHTML = '‚è∫Ô∏è';
                        recordBtn.classList.remove('active');

                        document.getElementById('recordingStatus').classList.add('hidden');

                        if (this.recordingTimer) {
                            clearInterval(this.recordingTimer);
                        }
                    }
                }

                saveRecording() {
                    const blob = new Blob(this.recordedChunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);

                    const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
                    const filename = `simple-podcast-${timestamp}.webm`;

                    // Create download link
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    // Show success message
                    alert(`Recording saved as ${filename}`);

                    // Clean up
                    setTimeout(() => URL.revokeObjectURL(url), 10000);
                }

                startRecordingTimer() {
                    this.recordingTimer = setInterval(() => {
                        if (this.isRecording && this.recordingStartTime) {
                            const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
                            document.getElementById('recordingTimer').textContent = this.formatTime(elapsed);
                        }
                    }, 1000);
                }

                formatTime(seconds) {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;

                    return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                }

                endSession() {
                    if (confirm('Are you sure you want to end the session?')) {
                        console.log('üõë Ending session');

                        // Stop announcement intervals
                        if (this.hostAnnouncementInterval) {
                            clearInterval(this.hostAnnouncementInterval);
                            this.hostAnnouncementInterval = null;
                        }

                        if (this.guestAnnouncementInterval) {
                            clearInterval(this.guestAnnouncementInterval);
                            this.guestAnnouncementInterval = null;
                        }

                        // Notify other participant
                        if (!this.isHost) {
                            this.sendSignalingMessage('guest-disconnected', { timestamp: Date.now() });
                        }

                        // Stop signaling
                        this.stopSignaling();

                        // Stop recording if active
                        if (this.isRecording) {
                            this.stopRecording();
                        }

                        // Close peer connection
                        if (this.peerConnection) {
                            this.peerConnection.close();
                        }

                        // Stop local media
                        if (this.localStream) {
                            this.localStream.getTracks().forEach(track => track.stop());
                        }

                        // Clean up session data if host
                        if (this.isHost && this.sessionId) {
                            localStorage.removeItem(`session_${this.sessionId}`);
                            localStorage.removeItem(`host_session_${this.sessionId}`);
                            localStorage.removeItem(`signaling_${this.sessionId}_host`);
                            localStorage.removeItem(`signaling_${this.sessionId}_guest`);
                            localStorage.removeItem(`global_signaling_${this.sessionId}`);
                        }

                        // Reset to welcome screen
                        this.resetToWelcome();
                    }
                }

                resetToWelcome() {
                    // Stop signaling
                    this.stopSignaling();

                    // Hide all sections
                    document.getElementById('sessionSetup').classList.add('hidden');
                    document.getElementById('deviceTesting').classList.add('hidden');
                    document.getElementById('sessionInterface').classList.add('hidden');

                    // Show welcome screen
                    document.getElementById('welcomeScreen').classList.remove('hidden');
                    document.querySelector('.action-buttons').classList.remove('hidden');
                    document.getElementById('joinForm').classList.add('hidden');

                    // Reset form values
                    document.getElementById('podcastTitle').value = 'My Awesome Podcast';
                    document.getElementById('hostName').value = 'Host';
                    document.getElementById('podcastDescription').value = '';
                    document.getElementById('sessionIdInput').value = '';
                    document.getElementById('guestNameInput').value = '';

                    // Reset state
                    this.localStream = null;
                    this.remoteStream = null;
                    this.peerConnection = null;
                    this.mediaRecorder = null;
                    this.recordedChunks = [];
                    this.isHost = false;
                    this.isRecording = false;
                    this.sessionId = null;
                    this.participantName = '';
                    this.recordingStartTime = null;
                    this.guestName = '';
                    this.isConnected = false;
                    this.lastMessageTimestamp = 0;
                    this.lastGlobalMessageTimestamp = 0;
                    this.broadcastChannel = null;

                    if (this.recordingTimer) {
                        clearInterval(this.recordingTimer);
                    }
                }

                // Enhanced signaling with broadcast messaging for cross-tab communication
                sendBroadcastMessage(type, data) {
                    // Use BroadcastChannel for cross-tab communication if available
                    if (window.BroadcastChannel) {
                        const channel = new BroadcastChannel(`podcast_${this.sessionId}`);
                        channel.postMessage({
                            type: type,
                            data: data,
                            from: this.isHost ? 'host' : 'guest',
                            timestamp: Date.now()
                        });

                        // Listen for responses
                        channel.onmessage = (event) => {
                            this.handleBroadcastMessage(event.data);
                        };

                        // Store channel reference
                        this.broadcastChannel = channel;
                    }

                    // Also store in localStorage as fallback
                    const globalKey = `global_signaling_${this.sessionId}`;
                    const messages = JSON.parse(localStorage.getItem(globalKey) || '[]');
                    messages.push({
                        type: type,
                        data: data,
                        from: this.isHost ? 'host' : 'guest',
                        timestamp: Date.now()
                    });

                    // Keep only recent messages (last 50)
                    if (messages.length > 50) {
                        messages.splice(0, messages.length - 50);
                    }

                    localStorage.setItem(globalKey, JSON.stringify(messages));
                }

                handleBroadcastMessage(message) {
                    // Handle cross-tab messages
                    const isFromOtherParticipant = (this.isHost && message.from === 'guest') ||
                        (!this.isHost && message.from === 'host');

                    if (isFromOtherParticipant) {
                        this.handleSignalingMessage(message);
                    }
                }

                startSignaling() {
                    if (this.signalingInterval) {
                        clearInterval(this.signalingInterval);
                    }

                    // Set up BroadcastChannel if available
                    if (window.BroadcastChannel && !this.broadcastChannel) {
                        this.broadcastChannel = new BroadcastChannel(`podcast_${this.sessionId}`);
                        this.broadcastChannel.onmessage = (event) => {
                            this.handleBroadcastMessage(event.data);
                        };
                    }

                    this.signalingInterval = setInterval(() => {
                        this.checkForSignalingMessages();
                        this.checkGlobalSignalingMessages();
                    }, 1000);
                }

                checkForSignalingMessages() {
                    const senderType = this.isHost ? 'guest' : 'host';
                    const key = `signaling_${this.sessionId}_${senderType}`;
                    const messageStr = localStorage.getItem(key);

                    if (messageStr) {
                        try {
                            const message = JSON.parse(messageStr);
                            const messageKey = `${message.type}_${message.timestamp}`;

                            // Avoid processing the same message multiple times
                            if (!this.processedMessages) {
                                this.processedMessages = new Set();
                            }

                            if (!this.processedMessages.has(messageKey)) {
                                this.processedMessages.add(messageKey);
                                console.log('üì• Processing stored message:', message.type);
                                this.handleSignalingMessage(message);

                                // Clean up old processed messages
                                if (this.processedMessages.size > 50) {
                                    this.processedMessages.clear();
                                }
                            }
                        } catch (error) {
                            console.error('Error parsing signaling message:', error);
                        }
                    }
                }

                checkGlobalSignalingMessages() {
                    const globalKey = `global_signaling_${this.sessionId}`;
                    const messagesStr = localStorage.getItem(globalKey);

                    if (messagesStr) {
                        try {
                            const messages = JSON.parse(messagesStr);
                            const relevantMessages = messages.filter(msg => {
                                const isFromOtherParticipant = (this.isHost && msg.from === 'guest') ||
                                    (!this.isHost && msg.from === 'host');
                                return isFromOtherParticipant;
                            });

                            if (!this.processedMessages) {
                                this.processedMessages = new Set();
                            }

                            for (const message of relevantMessages) {
                                const messageKey = `${message.type}_${message.timestamp}`;
                                if (!this.processedMessages.has(messageKey)) {
                                    this.processedMessages.add(messageKey);
                                    console.log('üì• Processing global message:', message.type);
                                    this.handleSignalingMessage(message);
                                }
                            }
                        } catch (error) {
                            console.error('Error parsing global signaling messages:', error);
                        }
                    }
                }

                stopSignaling() {
                    if (this.signalingInterval) {
                        clearInterval(this.signalingInterval);
                        this.signalingInterval = null;
                    }

                    if (this.broadcastChannel) {
                        this.broadcastChannel.close();
                        this.broadcastChannel = null;
                    }
                }

                sendSignalingMessage(type, data) {
                    const message = {
                        type: type,
                        data: data,
                        from: this.isHost ? 'host' : 'guest',
                        timestamp: Date.now(),
                        sessionId: this.sessionId
                    };

                    const key = `signaling_${this.sessionId}_${this.isHost ? 'host' : 'guest'}`;
                    localStorage.setItem(key, JSON.stringify(message));

                    // Also send via broadcast for better cross-tab communication
                    this.sendBroadcastMessage(type, data);
                }

                checkForSignalingMessages() {
                    const senderType = this.isHost ? 'guest' : 'host';
                    const key = `signaling_${this.sessionId}_${senderType}`;
                    const messageStr = localStorage.getItem(key);

                    if (messageStr) {
                        try {
                            const message = JSON.parse(messageStr);
                            if (message.timestamp > (this.lastMessageTimestamp || 0)) {
                                this.lastMessageTimestamp = message.timestamp;
                                this.handleSignalingMessage(message);
                            }
                        } catch (error) {
                            console.error('Error parsing signaling message:', error);
                        }
                    }
                }

                async handleSignalingMessage(message) {
                    console.log(`üì® Received signaling message: ${message.type} from ${message.from}`);

                    // Ensure we have a peer connection before processing messages
                    if (!this.peerConnection) {
                        console.log('‚ö†Ô∏è No peer connection yet, setting up...');
                        this.setupPeerConnection();
                    }

                    switch (message.type) {
                        case 'session-ready':
                        case 'host-ready':
                            if (!this.isHost) {
                                console.log('üéØ Guest found host ready signal');
                                document.getElementById('sessionTitle').textContent = message.data.podcastTitle || 'Podcast Session';
                                document.getElementById('hostLabel').textContent = message.data.hostName || 'Host';
                                this.updateConnectionStatus('connecting', `Found ${message.data.hostName}, connecting...`);

                                // Clear the looking placeholder
                                const hostVideo = document.getElementById('hostVideo');
                                hostVideo.innerHTML = '<div style="display: flex; align-items: center; justify-content: center; height: 100%; color: white; font-size: 1.5em;">üé§ Host Found - Connecting...</div>';
                            }
                            break;

                        case 'guest-joined':
                        case 'guest-looking':
                            if (this.isHost) {
                                console.log('üë• Host received guest presence signal');
                                this.guestName = message.data.guestName;
                                this.onGuestJoined();

                                // Clear host announcement interval
                                if (this.hostAnnouncementInterval) {
                                    clearInterval(this.hostAnnouncementInterval);
                                    this.hostAnnouncementInterval = null;
                                }

                                // Start WebRTC offer creation with delay
                                setTimeout(async () => {
                                    console.log('üé¨ Host starting WebRTC offer creation...');
                                    await this.createOffer();
                                }, 1000);
                            }
                            break;

                        case 'offer':
                            if (!this.isHost) {
                                console.log('üì• Guest received offer from host');

                                // Clear guest announcement interval
                                if (this.guestAnnouncementInterval) {
                                    clearInterval(this.guestAnnouncementInterval);
                                    this.guestAnnouncementInterval = null;
                                }

                                await this.handleOffer(message.data);
                            }
                            break;

                        case 'answer':
                            if (this.isHost) {
                                console.log('üì• Host received answer from guest');
                                await this.handleAnswer(message.data);
                            }
                            break;

                        case 'ice-candidate':
                            console.log('üßä Received ICE candidate');
                            await this.handleIceCandidate(message.data);
                            break;

                        case 'guest-disconnected':
                            if (this.isHost) {
                                console.log('üëã Guest disconnected');
                                this.onGuestDisconnected();
                            }
                            break;
                    }
                }
            }

            // Initialize the application when DOM is loaded
            document.addEventListener('DOMContentLoaded', () => {
                // Check for secure context
                if (!window.isSecureContext) {
                    document.body.innerHTML = `
                    <div style="padding: 40px; text-align: center; font-family: Arial, sans-serif; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); min-height: 100vh; color: white;">
                        <h1>üîí Secure Context Required</h1>
                        <p style="font-size: 18px; margin: 20px 0;">This application requires HTTPS or localhost to access camera and microphone.</p>
                        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px auto; max-width: 600px;">
                            <h3>To use Simple Podcast:</h3>
                            <ul style="text-align: left; display: inline-block;">
                                <li>Save this file and open it locally, OR</li>
                                <li>Serve it from localhost, OR</li>
                                <li>Deploy it to an HTTPS server</li>
                            </ul>
                        </div>
                    </div>
                `;
                    return;
                }

                // Initialize the application
                window.simplePodcast = new SimplePodcast();
            });
        </script>
    </body>
</html>